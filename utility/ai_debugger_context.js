
import { GoogleGenAI } from '@google/genai';
import { mkdirSync, existsSync, writeFileSync, readdirSync } from 'fs';
import path from 'path';
import { exec } from 'child_process';
import util from 'util';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import dotenv from 'dotenv';

// Get the directory name of the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Resolve the path to .env file
const envPath = resolve(__dirname, '../.env');

console.log('Current directory:', __dirname);
console.log('Env file path:', envPath);

// Load .env with the resolved path
const result = dotenv.config({
  path: envPath,
  debug: true // Enable debug mode
});

//console.log('Dotenv result:', result);
console.log('Environment variables:', {
  GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,
});

if (result.error) {
  console.error('Error loading .env file:', result.error);
  process.exit(1);
}

// Validate environment variable with more detailed error
const apiKey = process.env.GOOGLE_API_KEY;
if (!apiKey) {
  console.error('Environment variables loaded:', process.env);
  throw new Error(`GOOGLE_API_KEY environment variable is not set. 
    Check if .env file exists at: ${envPath}
    And contains: GOOGLE_API_KEY=your-key-here`);
}

const ai = new GoogleGenAI({
  apiKey,
});

//======================================================

const execPromise = util.promisify(exec);

const TESTDIR = '../tests';
const OUTPUT_FILE = 'google_navigation.spec.ts';
const OUTPUT_FILE_PATH = path.join(TESTDIR, OUTPUT_FILE);
const MAX_ATTEMPTS = 3;

// Function to get project structure context
function getProjectContext() {
  const projectFiles = [];

  function readDirRecursive(dir) {
    const items = readdirSync(dir, { withFileTypes: true });

    items.forEach(item => {
      const fullPath = path.join(dir, item.name);
      if (item.isDirectory() && !['node_modules', '.git'].includes(item.name)) {
        projectFiles.push(`📁 ${fullPath}`);
        readDirRecursive(fullPath);
      } else if (item.isFile() && item.name.endsWith('.ts') && item.name.endsWith('.js')) {
        projectFiles.push(`📄 ${fullPath}`);
      }
    });
  }

  readDirRecursive('../');
  return projectFiles.join('\n');
}

if (!existsSync(TESTDIR)) {
  mkdirSync(TESTDIR, { recursive: true });
}

const basePrompt = `Generate an accurate and fully executable Playwright test script in TypeScript.
Project Structure Context:
${getProjectContext()}

Current working directory: ${TESTDIR}
Target output file: ${OUTPUT_FILE}

Include meaningful inline comments to explain each step. The output should be code-only, with no explanation or description outside the code block. Also console log each test step.`;

// Rest of the code remains the same...


const userPrompt = `Navigate to google.com and click on "I'm Feeling Lucky", wait for 2 seconds,
then navigate to thoughtworks.com and wait for 2 seconds,
then navigate to google.com again`;

async function generateTestScript(errorContext) {
  const promptText = errorContext
    ? `${basePrompt}\n\nThe previous attempt failed with the following error:\n${errorContext}\nPlease correct the code and regenerate.`
    : basePrompt;

  const response = await ai.models.generateContent({
    model: 'gemini-2.0-flash',
    contents: [
      {
        role: 'user',
        parts: [{ text: promptText }],
      },
      {
        role: 'user',
        parts: [{ text: userPrompt }],
      },
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  const parts = response?.candidates?.[0]?.content?.parts || [];
  let output = '';

  parts.forEach((part) => {
    if (part.text) {
      const cleaned = part.text.split('\n').filter(line => !line.includes('```')).join('\n');
      output += `${cleaned}\n`;
    } else if (part.executableCode?.code) {
      output += `${part.executableCode.code}\n`;
    }
  });

  return `// *** This code is generated by AI Agent ***\n\n${output}`;
}

async function executeTestScript() {
  try {
    const { stdout, stderr } = await execPromise(`cd ../tests && npx playwright test ${OUTPUT_FILE}`);
    return { success: true, output: stdout };
  } catch (err) {
    return { success: false, output: err.stderr || err.message };
  }
}

async function generateAndDebug() {
  let attempt = 0;
  let success = false;
  let lastError = '';

  while (attempt < MAX_ATTEMPTS && !success) {
    console.log(`🧠 Attempt #${attempt + 1}...`);

    const code = await generateTestScript(lastError);
    writeFileSync(OUTPUT_FILE_PATH, code);

    const result = await executeTestScript();
    success = result.success;
    lastError = result.output;

    if (success) {
      console.log('✅ Test script executed successfully.');
      console.log(result.output);
    } else {
      console.warn(`❌ Script failed on attempt ${attempt + 1}. Error:\n${lastError}`);
    }

    attempt++;
  }

  if (!success) {
    console.error(`💥 All ${MAX_ATTEMPTS} attempts failed. Last error:\n${lastError}`);
  }
}

generateAndDebug();