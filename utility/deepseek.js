import { GoogleGenAI } from '@google/genai';
import { writeFileSync, existsSync, unlinkSync } from 'fs';
import { exec } from 'child_process';
import util from 'util';
import dotenv from 'dotenv';
import path from 'path';

dotenv.config();

const execPromise = util.promisify(exec);

// Configuration - should be moved to environment variables
const config = {
  AI_MODEL: 'gemini-2.0-flash',
  MAX_ATTEMPTS: 3,
  OUTPUT_FILE: 'deepseek.spec.js',
  PLAYWRIGHT_TIMEOUT: 30000, // 30 seconds
  DEBUG_MODE: true,
  SAFETY_CHECKS: true
};

const ai = new GoogleGenAI({
  apiKey: process.env.GOOGLE_API_KEY || "AIzaSyA7D07k9YdO701vF9Cgihd0ZLRCltxqx7o",
});

const basePrompt = `
Generate an accurate and fully executable Playwright test script in TypeScript. Include meaningful inline comments to explain each step. The output should be code-only, with no explanation or description outside the code block. Also console log each test step.
1. Include meaningful inline comments to explain each step
2. Add console.log() statements for important actions
3. Implement proper error handling with try/catch blocks
4. Use explicit waits only when absolutely necessary
5. Include proper test assertions
6. Follow Playwright best practices
7. Structure tests using describe/test blocks
8. Include proper test setup/teardown
9. Use page object pattern where appropriate
10. Ensure all selectors are robust and follow best practices

The output should be code-only, with no explanation or description outside the code block. 
Always verify the output is complete and executable before returning it.
`;

const userPrompt = `
Write a test that:
1. Navigates to google.com and verifies the page loaded
2. Clicks on "I'm Feeling Lucky" button
3. Waits for navigation to complete
4. Verifies the new page loaded
5. Navigates to thoughtworks.com
6. Verifies the page loaded
7. Navigates back to google.com
8. Verifies the page loaded again

Include all necessary imports and setup.
`;

async function generateTestScript(errorContext = '', previousCode = '') {
  try {
    const promptText = errorContext
      ? `${basePrompt}\n\nPrevious attempt failed with:\n${errorContext}\n\nPrevious code:\n\`\`\`javascript\n${previousCode}\n\`\`\`\n\nAnalyze the error, fix the code, and regenerate. Explain in comments what was fixed.`
      : basePrompt;

    const messages = [
      {
        role: 'user',
        parts: [{ text: promptText }],
      },
      {
        role: 'user',
        parts: [{ text: userPrompt }],
      }
    ];

    if (errorContext && config.DEBUG_MODE) {
      console.debug('\nüîß Debugging error:', errorContext);
    }

    const response = await ai.models.generateContent({
      model: config.AI_MODEL,
      contents: messages,
      config: {
        tools: [{ codeExecution: {} }],
        temperature: 0.2, // Lower temperature for more deterministic output
        topP: 0.9,
        maxOutputTokens: 2000
      },
    });

    const parts = response?.candidates?.[0]?.content?.parts || [];
    let output = '';

    // Process all parts of the response
    parts.forEach((part) => {
      if (part.text) {
        // Extract code blocks and clean up markdown
        const codeBlocks = part.text.match(/```javascript([\s\S]*?)```/g) || [];
        codeBlocks.forEach(block => {
          output += block.replace(/```javascript|```/g, '').trim() + '\n\n';
        });
      } else if (part.executableCode?.code) {
        output += `${part.executableCode.code}\n\n`;
      }
    });

    if (!output.trim()) {
      throw new Error('No valid code generated by AI');
    }

    // Add generation metadata
    const metaComment = `// Auto-generated by AI (Attempt ${errorContext ? 'retry' : 'initial'})
// ${new Date().toISOString()}
// Model: ${config.AI_MODEL}\n\n`;

    return metaComment + output;
  } catch (error) {
    console.error('‚ùå Error generating test script:', error);
    throw error;
  }
}

async function executeTestScript() {
  try {
    if (!existsSync(config.OUTPUT_FILE)) {
      throw new Error(`Test file ${config.OUTPUT_FILE} not found`);
    }

    // Clean up any previous test results
    const resultsDir = path.join(process.cwd(), 'test-results');
    if (existsSync(resultsDir)) {
      try {
        await execPromise(`rm -rf ${resultsDir}`);
      } catch (cleanError) {
        console.warn('‚ö†Ô∏è Could not clean test results directory:', cleanError);
      }
    }

    const { stdout, stderr } = await execPromise(`npx playwright test ${config.OUTPUT_FILE} --timeout=${config.PLAYWRIGHT_TIMEOUT}`, {
      env: { ...process.env, CI: 'true' }
    });

    if (stderr && stderr.includes('Error')) {
      return { success: false, output: stderr };
    }
    return { success: true, output: stdout };
  } catch (err) {
    return { 
      success: false, 
      output: err.stderr || err.stdout || err.message 
    };
  }
}

function validateGeneratedCode(code) {
  if (config.SAFETY_CHECKS) {
    // Basic safety checks
    const forbiddenPatterns = [
      /eval\(/,
      /new Function\(/,
      /require\(['"]child_process['"]\)/,
      /execSync\(/,
      /spawnSync\(/,
      /process\.env\.\w+\s*=\s*/,
      /fs\.writeFileSync\(/,
      /fetch\(['"]http:\/\// // Block non-HTTPS URLs
    ];

    for (const pattern of forbiddenPatterns) {
      if (pattern.test(code)) {
        console.error(`üö® Security violation detected: ${pattern}`);
        return false;
      }
    }
  }

  // Basic syntax validation
  const requiredImports = ['@playwright/test', 'expect'];
  for (const imp of requiredImports) {
    if (!code.includes(imp)) {
      console.error(`Missing required import: ${imp}`);
      return false;
    }
  }

  return true;
}

async function generateAndDebug() {
  let attempt = 0;
  let success = false;
  let lastError = '';
  let previousCode = '';

  console.log('üöÄ Starting test generation and debugging process...');

  while (attempt < config.MAX_ATTEMPTS && !success) {
    attempt++;
    console.log(`\nüîÑ Attempt #${attempt} of ${config.MAX_ATTEMPTS}...`);

    try {
      const code = await generateTestScript(lastError, previousCode);
      previousCode = code;

      if (!validateGeneratedCode(code)) {
        lastError = 'Generated code failed validation checks';
        continue;
      }

      writeFileSync(config.OUTPUT_FILE, code);
    
      if (config.DEBUG_MODE) {
        console.log('\nGenerated code:\n', code);
      }

      const result = await executeTestScript();
      success = result.success;
      lastError = result.output;

      if (success) {
        console.log('\n‚úÖ Test script executed successfully!');
        console.log(result.output);
        
        // Generate a report
        try {
          const { stdout } = await execPromise('npx playwright show-report');
          console.log('\nüìä Test report available at:', stdout.trim());
        } catch (reportError) {
          console.warn('Could not generate report:', reportError);
        }
      } else {
        console.warn(`\n‚ùå Attempt ${attempt} failed. Error:\n${lastError}`);
        
        // Save error log
        const errorLog = `// Error from attempt ${attempt}\n// ${new Date().toISOString()}\n\n${lastError}\n\n// Generated code:\n\n${code}`;
        writeFileSync(`error_attempt_${attempt}.log`, errorLog);
      }
    } catch (genError) {
      console.error('‚ö†Ô∏è Error during generation/execution:', genError);
      lastError = genError.message;
    }
  }

  if (!success) {
    console.error(`\nüí• All ${config.MAX_ATTEMPTS} attempts failed. Last error:\n${lastError}`);
    process.exit(1);
  } else {
    console.log('\nüéâ Successfully generated and executed test script!');
    process.exit(0);
  }
}

// Clean up on exit
process.on('exit', () => {
  if (existsSync(config.OUTPUT_FILE)) {
    // unlinkSync(config.OUTPUT_FILE); // Uncomment to clean up
  }
});

generateAndDebug();