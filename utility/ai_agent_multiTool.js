import { GoogleGenAI } from '@google/genai';
import { mkdirSync, existsSync, writeFileSync, readdirSync } from 'fs';
import path from 'path';
import { exec } from 'child_process';
import util from 'util';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import dotenv from 'dotenv';

// Get the directory name of the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Resolve the path to .env file
const envPath = resolve(__dirname, '../.env');

console.log('Current directory:', __dirname);
console.log('Env file path:', envPath);

// Load .env with the resolved path
const result = dotenv.config({
  path: envPath,
  debug: true
});

console.log('Environment variables:', {
  GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,
});

if (result.error) {
  console.error('Error loading .env file:', result.error);
  process.exit(1);
}

// Validate environment variable
const apiKey = process.env.GOOGLE_API_KEY;
if (!apiKey) {
  console.error('Environment variables loaded:', process.env);
  throw new Error(`GOOGLE_API_KEY environment variable is not set. 
    Check if .env file exists at: ${envPath}
    And contains: GOOGLE_API_KEY=your-key-here`);
}

const ai = new GoogleGenAI({
  apiKey,
});

const execPromise = util.promisify(exec);

// Define constants for different frameworks
const FRAMEWORKS = {
  PLAYWRIGHT: 'playwright',
  SELENIUM: 'selenium',
  TESTCAFE: 'testcafe',
  APPIUM: 'appium'
};

const TESTDIR = '../tests';
const BASE_FILENAME = 'google_navigation';
const OUTPUT_FILES = {
  [FRAMEWORKS.PLAYWRIGHT]: `${BASE_FILENAME}.playwright.spec.ts`,
  [FRAMEWORKS.SELENIUM]: `${BASE_FILENAME}.selenium.spec.mts`, // Use .mts for ESM TypeScript
  [FRAMEWORKS.TESTCAFE]: `${BASE_FILENAME}.testcafe.ts`,
  [FRAMEWORKS.APPIUM]: `${BASE_FILENAME}.appium.spec.ts`
};

const MAX_ATTEMPTS = 3;

// Function to get project structure context
function getProjectContext() {
  const projectFiles = [];

  function readDirRecursive(dir) {
    const items = readdirSync(dir, { withFileTypes: true });

    items.forEach(item => {
      const fullPath = path.join(dir, item.name);
      if (item.isDirectory() && !['node_modules', '.git'].includes(item.name)) {
        projectFiles.push(`ðŸ“ ${fullPath}`);
        readDirRecursive(fullPath);
      } else if (item.isFile() && (item.name.endsWith('.ts') || item.name.endsWith('.js'))) {
        projectFiles.push(`ðŸ“„ ${fullPath}`);
      }
    });
  }

  readDirRecursive('../');
  return projectFiles.join('\n');
}

// Create test directory if it doesn't exist
if (!existsSync(TESTDIR)) {
  mkdirSync(TESTDIR, { recursive: true });
}

// Generate framework-specific prompts
function getFrameworkPrompt(framework, errorContext = '') {
  const basePrompt = `Generate an accurate and fully executable ${framework} test script with suitable extension.
Project Structure Context:
${getProjectContext()}

Current working directory: ${TESTDIR}
Target output file: ${OUTPUT_FILES[framework]}

Include meaningful inline comments to explain each step. The output should be code-only, with no explanation or description outside the code block. Also console log each test step.

${framework === FRAMEWORKS.SELENIUM ? 'Use Selenium WebDriver with TypeScript.' : ''}
${framework === FRAMEWORKS.TESTCAFE ? 'Use TestCafe with TypeScript.' : ''}
${framework === FRAMEWORKS.APPIUM ? 'Use Appium with TypeScript for web testing.' : ''}
`;

  return errorContext
    ? `${basePrompt}\n\nThe previous attempt failed with the following error:\n${errorContext}\nPlease correct the code and regenerate.`
    : basePrompt;
}

async function generateTestScript(framework, errorContext) {
  const promptText = getFrameworkPrompt(framework, errorContext);

  const userPrompt = `Navigate to google.com and click on "I'm Feeling Lucky", wait for 2 seconds,
then navigate to thoughtworks.com and wait for 2 seconds,
then navigate to google.com again`;

  const response = await ai.models.generateContent({
    model: 'gemini-2.0-flash',
    contents: [
      {
        role: 'user',
        parts: [{ text: promptText }],
      },
      {
        role: 'user',
        parts: [{ text: userPrompt }],
      },
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  const parts = response?.candidates?.[0]?.content?.parts || [];
  let output = '';

  parts.forEach((part) => {
    if (part.text) {
      const cleaned = part.text.split('\n').filter(line => !line.includes('```')).join('\n');
      output += `${cleaned}\n`;
    } else if (part.executableCode?.code) {
      output += `${part.executableCode.code}\n`;
    }
  });

  return `// *** This code is generated by AI Agent for ${framework} ***\n\n${output}`;
}

async function executeTestScript(framework, filePath) {
  try {
    let command;
    switch (framework) {
      case FRAMEWORKS.PLAYWRIGHT:
        command = `npx playwright test ${path.basename(filePath)}`;
        break;
      /*case FRAMEWORKS.SELENIUM:
        // Use mocha with ts-node/esm loader for .mts (ESM TypeScript) support
        command = `npx mocha --loader ts-node/esm ${path.basename(filePath)}`;
        break;*/
      case FRAMEWORKS.TESTCAFE:
        command = `npx testcafe chrome ${path.basename(filePath)}`;
        break;
     /* case FRAMEWORKS.APPIUM:
        command = `npx ts-node ${path.basename(filePath)}`;
        break; */
      default:
        throw new Error(`Unknown framework: ${framework}`);
    }

    const { stdout, stderr } = await execPromise(`cd ${TESTDIR} && ${command}`);
    return { success: true, output: stdout };
  } catch (err) {
    return { success: false, output: err.stderr || err.message };
  }
}

async function generateAndDebugForFramework(framework) {
  let attempt = 0;
  let success = false;
  let lastError = '';
  const outputPath = path.join(TESTDIR, OUTPUT_FILES[framework]);

  console.log(`\nðŸ”§ Generating tests for ${framework}...`);

  while (attempt < MAX_ATTEMPTS && !success) {
    console.log(`ðŸ§  Attempt #${attempt + 1}...`);

    const code = await generateTestScript(framework, lastError);
    writeFileSync(outputPath, code);

    const result = await executeTestScript(framework, outputPath);
    success = result.success;
    lastError = result.output;

    if (success) {
      console.log(`âœ… ${framework} test script executed successfully.`);
      console.log(result.output);
    } else {
      console.warn(`âŒ ${framework} script failed on attempt ${attempt + 1}. Error:\n${lastError}`);
    }

    attempt++;
  }

  if (!success) {
    console.error(`ðŸ’¥ All ${MAX_ATTEMPTS} attempts failed for ${framework}. Last error:\n${lastError}`);
  }
}

async function generateAllTests() {
  for (const framework of Object.values(FRAMEWORKS)) {
    await generateAndDebugForFramework(framework);
  }
}

// First, install required dependencies
const dependencies = {
  [FRAMEWORKS.PLAYWRIGHT]: ['@playwright/test', 'playwright'],
  [FRAMEWORKS.SELENIUM]: [
    'selenium-webdriver',
    '@types/selenium-webdriver',
    'mocha',
    '@types/mocha',
    'chai',
    '@types/chai',
    'ts-mocha',
    'typescript'
  ],
  [FRAMEWORKS.TESTCAFE]: ['testcafe'],
  [FRAMEWORKS.APPIUM]: ['webdriverio', 'appium', '@wdio/appium-service']
};

async function installDependencies() {
  console.log('ðŸ“¦ Installing required dependencies...');
  for (const [framework, deps] of Object.entries(dependencies)) {
    try {
      console.log(`Installing ${framework} dependencies...`);
      await execPromise(`npm install -D ${deps.join(' ')}`);
    } catch (error) {
      console.error(`Failed to install ${framework} dependencies:`, error);
    }
  }
}

async function createTsConfig() {
  const tsConfigPath = path.join(TESTDIR, '..', 'tsconfig.json');
  if (!existsSync(tsConfigPath)) {
    const tsConfig = {
      "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "lib": ["es2020", "DOM"],
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "moduleResolution": "node",
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "types": ["node", "mocha", "selenium-webdriver"]
      },
      "include": ["tests/**/*"],
      "exclude": ["node_modules"]
    };

    writeFileSync(tsConfigPath, JSON.stringify(tsConfig, null, 2));
    console.log('Created tsconfig.json');
  }
}

// Main execution
(async () => {
  await installDependencies();
  await createTsConfig();
  await generateAllTests();
})();